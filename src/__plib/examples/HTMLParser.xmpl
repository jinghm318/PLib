<?php
/* The first example uses a simple standalone callback function where we just 
 * output the tags that has an "id" attribute.
*/

PLib::Import('Parser.HTMLParser');
PLib::Import('Protocols.HTTPClient');

/**
 * Function called for each tag that the HTML parser finds.
 * NOTE! The last argument doesn't contain the content of the tag, it's
 * the unparsed tag i.e. <a href='page.html'>
*/
function myTagCallback(HTMLParser $p, $tagname, $attr, $data)
{
  if (isset($attr['id']))
    wbr("Tag: <strong>%s</strong>, ID: <strong>%s</strong>", 
        $tagname, $attr['id']);
}

try {
  $cli = new HTTPClient();
	$cli->Cache(3600);
  $cli->Get("http://www.poppa.se/");
  
  if ($cli->StatusCode() != 200)
    throw new Exception("Got status code " . $cli->StatusCode() . 
                        " so I abort");

  $parser = new HTMLParser();
  $parser->SetTagCallback('myTagCallback');
  $parser->Parse($cli->Data());
}
catch (Exception $e) {
  die($e->getMessage());
}

/* Result of the first example

Tag: body, ID: home
Tag: div, ID: header
Tag: div, ID: header-wrapper
Tag: div, ID: header-title
Tag: div, ID: header-search
Tag: input, ID: s-query
Tag: div, ID: wrapper
Tag: div, ID: content
Tag: div, ID: content-content
Tag: div, ID: meta
Tag: img, ID: portrait
Tag: div, ID: page-footer
Tag: div, ID: css-checker

*/

//===================== END OF FIRST EXAMPLE =================================
?>

<?php
/* The second example is a little bit more complex. 
 * The goal here is to turn the content of the web page (the start page at 
 * my - Pontus Östlund - blog) into a plain text file.
 * 
 * I skip the navigation and all other stuff. Only the latest entries will
 * we "textified".
*/
PLib::Import('Parser.HTMLParser');
PLib::Import('Protocols.HTTPClient');

class HTML2Text extends HTMLParser
{
  private $buffer = null;
  private $subbuffer = null;
  private $capture = 0;
  private $subcapture = 0;

  public function __construct()
  {
    parent::__construct();
  }
  
  private function nl()
  {
    $this->buffer .= "\n";
  }
  
  private function space()
  {
    $prevchr = $this->buffer[strlen($this->buffer) - 1];
    if (strcspn($prevchr, " \n\t,"))
      $this->buffer .= ' ';
  }
  
  protected function tagCallback(HTMLParser $p, $tag, $attr, $data)
  {
    if ($tag == 'img' || $tag == 'br')
      return;

    $class = isset($attr['class']) ? $attr['class'] : null;

    if ($this->capture == 0 && $tag == 'title') {
      $this->capture = 1;
      return;
    }
    
    if ($this->capture == 2 && $tag == 'div' && $class == 'entry') {
      $this->capture = 3;
      return;
    }
    
    if ($this->capture == 3 && $tag != '/div') {
      switch ($tag) {
        case 'h2':
          $this->nl();
          $this->nl();
          $this->buffer .= "* ";
          $this->subcapture = 1;
          break;
        case '/h2':
          if ($this->subcapture == 1)
            $this->subcapture = 0;
        case 'small':
          $this->nl();
          break;
        case 'p':
          $this->subcapture = 3;
          $this->nl();
          break;
        case '/p':
          $this->subcapture = 0;
          $this->buffer .= wordwrap($this->subbuffer, 80);
          $this->subbuffer = null;
          break;
      }
    }
    elseif ($this->capture == 3 && $tag = '/div') {
      $this->capture = 2;
      return;
    }
  }
  
  protected function dataCallback(HTMLParser $p, $data)
  {
    if ($this->capture == 1) {
      $this->buffer .= strtoupper($data) . "\n" . str_repeat('=', 80);
      $this->capture = 2;
      return;
    }
    
    if ($this->capture == 3) {
      if ($this->subcapture < 3) {
        $data = trim($data);
        if ($this->subcapture == 1)
          $data = strtoupper($data);
        if (strlen($data) > 0) {
          if ($data == ",")
            $this->buffer .= ', ';
          else
            $this->buffer .= $this->space() . $data;
        }
      }
      else {
        $this->subbuffer .= $data;
      }
    }
  }
  
  public function Buffer()
  {
    return $this->buffer;
  }
}

try {
  $cli = new HTTPClient();
  $cli->Cache(3600);
  $cli->Get("http://www.poppa.se/blog/");

  if ($cli->StatusCode() != 200)
    throw new Exception("Got status code " . $cli->StatusCode() . 
                        " so I abort");

  $parser = new HTML2Text();
  $parser->Parse($cli->Data());

  echo rprint(utf8_encode($parser->Buffer()));
}
catch (Exception $e) {
  die($e->getMessage());
}

/* The result of the second example

PONTUS ÖSTLUND: HOME
================================================================================

* UPDATED ROXEN TRIM TAG
POSTED ON MONDAY 04, JUNE 2007 UNDER SHARED CODE, ROXEN, PIKE WITH NO COMMENTS

Jonas Walldén, CTO at Roxen, has improved my RXML tag contribution trim/trim.
The code is now really beautiful and you can tell the difference from the code
written by a lamer, as myself, and a real programmer, as Jonas. Jonas told me
that the trim/trim tag will be part of the next Roxen release :)

* BUG FIX FOR SYNTAXER.PMOD
POSTED ON MONDAY 21, MAY 2007 UNDER SHARED CODE, ROXEN, PIKE WITH NO COMMENTS

It didn't take too long to notice that I had f--ked up the HTMLParser class a
little bit. It was how entities was handled that didn't really worked as
expected - entities in tag attributes was duplicated and inserted in the tag
content - but the good side of it is that I learned about the context method of
the Parser.HTML Pike class. I only want to match entities in the data section -
i.e. tag content - and not in attributes and the context method tells you, as
the name implies, in what context the entity is found. So my entity callback
function now looks like:

* A PIKE SYNTAX HIGHLIGHTING MODULE
POSTED ON SUNDAY 20, MAY 2007 UNDER SHARED CODE, ROXEN, PIKE WITH NO COMMENTS

So I thought I should try to port my syntax highlighting script, Syntaxer,
written in PHP to Pike. Mostly for the fun of it but also to improve my
knowledge of string handling in Pike. The greatest concern here is that PHP is a
dynamic language and Pike is not (in the same sense) and the PHP version of
Syntaxer heavily depends on dynamic loading of PHP files. The reason for this is
that I generate the "syntax maps" dynamically from syntax files of Edit+. That
means that if you want support for a new language just drop a .stx file in the
right location and there you go. My script will convert that into a static PHP
file, so that the conversion only needs to be done once, and load that file on
the fly when that particular language is requested.

* A PIKE MODULE AND A ROXEN TAG
POSTED ON FRIDAY 11, MAY 2007 UNDER SHARED CODE, ROXEN, PIKE WITH NO COMMENTS

When you'r used to one programming language and start learning a new one you
sometimes miss some features from the former. That happened to me a couple of
years ago when we started using Roxen at work. What I missed was the trim
functions from PHP. Sure, Pike and RXML can trim strings from whitespace but the
beauty of trim, ltrim and rtrim in PHP is that you can trim characters as well
as whitespace. And to my knowledge there's no equivalent to rtrim and ltrim -
that is only trim the left and right side respectively of the string.

* PIKE MULTISET
POSTED ON THURSDAY 03, MAY 2007 UNDER PIKE WITH NO COMMENTS

It's fascinating: I've been using Pike for little over two years now and I have
never really understood the Pike data type "multiset". A multiset is the keys in
an associative array - or mapping as they are called in Pike, or hash in Perl,
or HashTable in C# - with the values left out. So if you have a Pike mapping
that looks like ([ "key1" : 1, "key2" : 2, "key3" : 3 ]) a multiset of that
would look like ( "key1", "key2", "key3" ) and an array would be ({ 1, 2, 3 }).
Mappings and arrays I have used a lot, of course, but it was quite recently it
came to me what the multiset is good for!

* BEAUTIFUL ROXEN
POSTED ON WEDNESDAY 02, MAY 2007 UNDER ROXEN, PIKE WITH NO COMMENTS

I've been really busy lately at work with various things - developing a blogging
system for starters. Most of the stuff you need for a blogging system is already
available in Roxen CMS that we use at work. But one thing I needed, that isn't
available, was some commenting functionality. This is something that you could
quite easily implement in the templates - Roxen uses XSLT for the templating
system, or their own extension of XSLT so that you can write RXML code in the
XSL templates.

* GENERATING PDFS ON THE FLY
POSTED ON FRIDAY 13, APRIL 2007 UNDER PROGRAMMING, ROXEN, C#/MONO WITH 1 COMMENT

One time or another you come to the point, at least when you work as a web
developer, when you need to generate PDFs on the fly. In principle this wouldn't
be too hard: pass the document you want to convert through a PDF printer. Well,
it doesn't sound that hard but talk is one thing and implementation another! I
came to the point recently where I, or we, really needed to generate PDFs on the
fly. The question of just converting one document to a PDF was not the only
problem ahead: We also needed to alter the content, which is some tremendously
complex content, of the PDF on the fly.

* SYNTAXER 2.0.2 RELEASED
POSTED ON SUNDAY 25, MARCH 2007 UNDER SHARED CODE WITH NO COMMENTS

A few bugs was fixed in this release. I also noted a few new ones but that was
mostly in the SyntaxMap class which gererates PHP arrays from the .stx files.

* REDROOM WITH NO COMMENT SPAM?
POSTED ON SUNDAY 25, MARCH 2007 UNDER MISC WITH NO COMMENTS

So I've worked some on Redroom and the main thing was to stop the ability for
robots to add comments. It will be interesting to see if it works or not, but if
it doesn't work I have a Captcha solution ready to use.

*/
?>